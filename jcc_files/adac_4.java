/* Generated By:JavaCC: Do not edit this line. adac_4.java */
package traductor;

import java.util.*;
import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.attributes.*;
import lib.errores.*;
import lib.tools.*;

import lib.tools.codeGeneration.CodeBlock;
import lib.tools.codeGeneration.PCodeInstruction.OpCode;
import lib.tools.codeGeneration.CGUtils;

import java.io.FileWriter;
import java.io.IOException;

public class adac_4 implements adac_4Constants {

        //tabla de símbolos global
        static SymbolTable st;
        static SemanticFunctions sf;

        static String fich;


        private static void initSymbolTable() {
                boolean b;
                String[] palsRes = {
                "var","const","escribir"
                };

                st = new SymbolTable(palsRes);
                //st.insertReservedWords(palsRes);

                //st.toString();
        }


    public static void main(String[] args) {
        adac_4 parser;



        try {
                if(args.length == 0) { //entrada desde stdin
                                parser = new adac_4(System.in);
                        }
                        else { //entrada desde fichero en args[0]
                    parser = new adac_4(new java.io.FileInputStream(args[0]));
                        }
                        initSymbolTable();
                        sf = new SemanticFunctions(st);
                        fich = args[0];
                        parser.programa(); //invoca símbolo inicial de la gramática
                        //System.out.println(st.toString());
                } catch (java.io.FileNotFoundException e) {
                        System.err.println ("Fichero " + args[0] + " no encontrado.");
                } catch (TokenMgrError e) {
                System.err.println("LEX_ERROR: " + e.getMessage());
        }
                catch (ParseException e){
                        System.err.println("PARSE_ERROR: " + e.getMessage());
                }
                catch(Exception e) {
                        System.err.println("Finalizo traducci\u00f3n por detecci\u00f3n de error no controlado: \n\t"
                                               + e.getMessage());
                }
    }

//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
/*	<tPROC>
	<tID>
	<tIS>
	declaracion_variables()
	declaracion_procs_funcs()
	bloque_sentencias()*/
  static final public void programa() throws ParseException {
        Token t;
        Attributes at1 = new Attributes();
        Attributes at2 = new Attributes();

        CodeBlock cprog, cprodfun, cbloque;
        String etiq;
    jj_consume_token(tPROC);
    t = jj_consume_token(tID);
    jj_consume_token(tIS);
                sf.programa_1(t, at1);

                cprog = new CodeBlock();
                etiq = CGUtils.newLabel();
                CGUtils.memorySpaces[st.level] = 2;
                cprog.addInst(OpCode.ENP, etiq);
                cprog.addComment("Comienzo de " + t.image);
    declaracion_variables();
    declaracion_procs_funcs(at1);
                cprog.addBlock(at1.code);
    bloque_sentencias(at2);
                cprog.addLabel(etiq);
                cprog.addBlock(at2.code);
                cprog.addComment("Fin de "  + t.image);
                cprog.addInst(OpCode.LVP);

                if(ErrorSemantico.getContadorErrores() == 0){
                        String name = "";
                        try {
                                int i = fich.lastIndexOf('.');
                                name = fich.substring(0,i);
                                FileWriter myWriter = new FileWriter(name + ".pcode");
                                myWriter.write(cprog.toString());
                                myWriter.close();

                        }
                        catch (Exception e) {
                e.getStackTrace();
                }
                        System.out.println("Compilacion finalizada. Se ha generado el fichero " + name + ".pcode");
                }
  }

//( declaracion() <tPC> )*
  static final public void declaracion_variables() throws ParseException {
        Attributes at1 = new Attributes();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tBOOL:
      case tCHAR:
      case tINT:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      declaracion(at1);
      jj_consume_token(tPC);
    }
  }

//tipo_variable() lista_vars()
  static final public void declaracion(Attributes at) throws ParseException {
    at.type = tipo_variable();
    lista_vars(at);
  }

//<tINT> | <tCHAR> | <tBOOL>
  static final public Symbol.Types tipo_variable() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tINT:
      jj_consume_token(tINT);
                        {if (true) return Symbol.Types.INT;}
      break;
    case tCHAR:
      jj_consume_token(tCHAR);
                        {if (true) return Symbol.Types.CHAR;}
      break;
    case tBOOL:
      jj_consume_token(tBOOL);
                        {if (true) return Symbol.Types.BOOL;}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//variable() ( <tC> variable() )*
  static final public void lista_vars(Attributes at) throws ParseException {
    variable(at);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tC:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      jj_consume_token(tC);
      variable(at);
    }
  }

/*
	LOOKAHEAD(2)
	<tID> <tISQBR> <tVINT> <tESQBR>
	| <tID>
*/
  static final public void variable(Attributes at) throws ParseException {
        Token t1, t2;
        Symbol s = null;
    if (jj_2_1(2)) {
      t1 = jj_consume_token(tID);
      jj_consume_token(tISQBR);
      t2 = jj_consume_token(tVINT);
      jj_consume_token(tESQBR);
                //crear e instertar el simbolo
                s = new SymbolArray(t1.image, 0, Integer.parseInt(t2.image)-1,at.type,at.parClass);
                if(at.parClass == Symbol.ParameterClass.NONE){
                        s.dir = CGUtils.memorySpaces[st.level] + 1;
                        CGUtils.memorySpaces[st.level] += Integer.parseInt(t2.image);
                        try{
                                st.insertSymbol(s);
                        }
                        catch (AlreadyDefinedSymbolException e) {
                                ErrorSemantico.deteccion(e, t1);
                        }
                } else{at.parList.add(s);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tID:
        t1 = jj_consume_token(tID);
                  //crear e insertar el simbolo
                        if(at.type == Symbol.Types.INT){
                                s = new SymbolInt(t1.image, at.parClass);
                        }
                        else if(at.type == Symbol.Types.CHAR){
                                s = new SymbolChar(t1.image, at.parClass);
                        }
                        else{
                                s = new SymbolBool(t1.image, at.parClass);
                        }
                        if(at.parClass == Symbol.ParameterClass.NONE){
                                CGUtils.memorySpaces[st.level]++;
                                s.dir = CGUtils.memorySpaces[st.level];
                                try{
                                        st.insertSymbol(s);
                                }
                                catch (AlreadyDefinedSymbolException e) {
                                        ErrorSemantico.deteccion(e, t1);
                                }
                        } else{at.parList.add(s);}
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void declaracion_procs_funcs(Attributes at) throws ParseException {
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPROC:
      case tFUNCT:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      declaracion_proc_func(at);
    }
  }

/*(<tPROC> | <tFUNCT> tipo_variable())
	declaracion_proc_func2()
*/
  static final public void declaracion_proc_func(Attributes at) throws ParseException {
        Token t1;
        String etiq;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tPROC:
      jj_consume_token(tPROC);
      t1 = jj_consume_token(tID);
      cabecera_proc(at, t1);
      break;
    case tFUNCT:
      jj_consume_token(tFUNCT);
         at.type = tipo_variable();
      t1 = jj_consume_token(tID);
      cabecera_func(at, t1);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                etiq = CGUtils.newLabel();
                at.code.addInst(OpCode.JMP, etiq);
    declaracion_variables();
    declaracion_procs_funcs(at);
                at.code.addLabel(etiq);
    bloque_sentencias(at);
                at.code.addInst(OpCode.CSF);
                st.removeBlock();
  }

/*
cabecera_proc_func()
declaracion_variables()
declaracion_procs_funcs()
bloque_sentencias()
*/
  static final public void cabecera_proc(Attributes at, Token t) throws ParseException {
        Attributes at1 = new Attributes();
        Symbol s = null;
    jj_consume_token(tSBR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tVAL:
    case tREF:
      argumentos_proc_func(at1);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(tEBR);
    jj_consume_token(tIS);
                try{
                        s = new SymbolProcedure(t.image, at1.parList) ;
                        s.label = CGUtils.newLabel();
                        st.insertSymbol(s);
                        at.code.addLabel(s.label);
                }
                catch (AlreadyDefinedSymbolException e) {
                        ErrorSemantico.deteccion(e, t);
                }

                at.simbolo = s;
                st.insertBlock();

                CGUtils.memorySpaces[st.level] = 2;

                //Insertamos los argumentos en la tabla de simbolos
                for (int i=0;i<at1.parList.size();i++) {
                        try{
                                if(at1.parList.get(i).type == Symbol.Types.ARRAY && at1.parList.get(i).parClass == Symbol.ParameterClass.VAL){
                                        at1.parList.get(i).dir = CGUtils.memorySpaces[st.level] + 1;
                                        CGUtils.memorySpaces[st.level] += ((SymbolArray)at1.parList.get(i)).maxInd + 1;
                                }
                                else{
                                        CGUtils.memorySpaces[st.level]++;
                                        at1.parList.get(i).dir = CGUtils.memorySpaces[st.level];
                                }
                                st.insertSymbol(at1.parList.get(i));
                        }
                        catch (AlreadyDefinedSymbolException e) {
                                ErrorSemantico.deteccion(e, t);
                        }
                }

                for (int i=at1.parList.size()-1; i >= 0; i--) {
                        if(at1.parList.get(i).type == Symbol.Types.ARRAY && at1.parList.get(i).parClass == Symbol.ParameterClass.VAL){
                                for(int j = ((SymbolArray)at1.parList.get(i)).maxInd; j >= 0; j--){
                                        at.code.addInst(OpCode.SRF, st.level - at1.parList.get(i).nivel, (int)at1.parList.get(i).dir + j);
                                        at.code.addInst(OpCode.ASGI);
                                }
                        }
                        else{
                                at.code.addInst(OpCode.SRF, st.level - at1.parList.get(i).nivel, (int)at1.parList.get(i).dir);
                                at.code.addInst(OpCode.ASGI);
                        }
                }
  }

  static final public void cabecera_func(Attributes at, Token t) throws ParseException {
        Attributes at1 = new Attributes();
        Symbol s = null;
    jj_consume_token(tSBR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tVAL:
    case tREF:
      argumentos_proc_func(at1);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    jj_consume_token(tEBR);
    jj_consume_token(tIS);
                try{
                        s = new SymbolFunction(t.image, at1.parList, at.type);
                        s.label = CGUtils.newLabel();
                        st.insertSymbol(s);
                        at.code.addLabel(s.label);
                }
                catch (AlreadyDefinedSymbolException e) {
                        ErrorSemantico.deteccion(e, t);
                }

                at.simbolo = s;
                st.insertBlock();

                CGUtils.memorySpaces[st.level] = 2;

                //Insertamos los argumentos en la tabla de simbolos
                for (int i=0;i<at1.parList.size();i++) {
                        try{
                                if(at1.parList.get(i).type == Symbol.Types.ARRAY && at1.parList.get(i).parClass == Symbol.ParameterClass.VAL){
                                        at1.parList.get(i).dir = CGUtils.memorySpaces[st.level] + 1;
                                        CGUtils.memorySpaces[st.level] += ((SymbolArray)at1.parList.get(i)).maxInd + 1;
                                }
                                else{
                                        CGUtils.memorySpaces[st.level]++;
                                        at1.parList.get(i).dir = CGUtils.memorySpaces[st.level];
                                }
                                st.insertSymbol(at1.parList.get(i));
                        }
                        catch (AlreadyDefinedSymbolException e) {
                                ErrorSemantico.deteccion(e, t);
                        }
                }

                for (int i=at1.parList.size()-1; i >= 0; i--) {
                        if(at1.parList.get(i).type == Symbol.Types.ARRAY && at1.parList.get(i).parClass == Symbol.ParameterClass.VAL){
                                for(int j = ((SymbolArray)at1.parList.get(i)).maxInd; j >= 0; j--){
                                        at.code.addInst(OpCode.SRF, st.level - at1.parList.get(i).nivel, (int)at1.parList.get(i).dir + j);
                                        at.code.addInst(OpCode.ASGI);
                                }
                        }
                        else{
                                at.code.addInst(OpCode.SRF, st.level - at1.parList.get(i).nivel, (int)at1.parList.get(i).dir);
                                at.code.addInst(OpCode.ASGI);
                        }
                }
  }

/*	(<tREF> | <tVAL>)
	declaracion()
	(<tPC> (<tREF> | <tVAL>) declaracion())*/
  static final public void argumentos_proc_func(Attributes at1) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tREF:
      jj_consume_token(tREF);
         at1.parClass = Symbol.ParameterClass.REF;
      break;
    case tVAL:
      jj_consume_token(tVAL);
         at1.parClass = Symbol.ParameterClass.VAL;
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    declaracion(at1);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPC:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      jj_consume_token(tPC);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tREF:
        jj_consume_token(tREF);
         at1.parClass = Symbol.ParameterClass.REF;
        break;
      case tVAL:
        jj_consume_token(tVAL);
         at1.parClass = Symbol.ParameterClass.VAL;
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      declaracion(at1);
    }
  }

  static final public void bloque_sentencias(Attributes at) throws ParseException {
    jj_consume_token(tBEGIN);
    lista_instrucciones(at);
    jj_consume_token(tEND);
  }

  static final public void instruccion(Attributes at) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPUT:
        inst_escribir(at);
        jj_consume_token(tPC);
        break;
      case tPUTL:
        inst_escribir_linea(at);
        jj_consume_token(tPC);
        break;
      case tRETURN:
        inst_return(at);
        jj_consume_token(tPC);
        break;
      case tSKIP:
        inst_saltar_linea(at);
        jj_consume_token(tPC);
        break;
      case tGET:
        inst_leer(at);
        jj_consume_token(tPC);
        break;
      case tWHILE:
        inst_iteracion(at);
        break;
      case tIF:
        inst_seleccion(at);
        break;
      default:
        jj_la1[11] = jj_gen;
        if (jj_2_2(2)) {
          inst_invoc_proc(at);
          jj_consume_token(tPC);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case tID:
            inst_asignacion(at);
            jj_consume_token(tPC);
            break;
          default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } catch (ParseException e) {
                Set<Integer> conjSinc = infoParseException(e);
                conjSinc.add(tPC);
                recuperacionPanico(e.currentToken.next, conjSinc);
    }
  }

//<tID> <tSBR> lista_cero_o_mas_exps(t) <tEBR>
  static final public void inst_invoc_proc(Attributes at) throws ParseException {
        Token t;
        Attributes at1 = new Attributes();
        at1.indice = 0;
    //procedimiento( )
            t = jj_consume_token(tID);
                sf.inst_invoc_proc_1(t, at1);
                at1.esLlamada = true;
    jj_consume_token(tSBR);
    lista_cero_o_mas_exps(at1);
    jj_consume_token(tEBR);
                sf.inst_invoc_proc_2(at1);
                at.code.addBlock(at1.code);
                at.code.addOSFInst(CGUtils.memorySpaces[st.level] + 1, st.level - at1.simbolo.nivel, at1.simbolo.label);
  }

  static final public void lista_instrucciones(Attributes at) throws ParseException {
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tRETURN:
      case tPUT:
      case tPUTL:
      case tSKIP:
      case tGET:
      case tIF:
      case tWHILE:
      case tID:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
      instruccion(at);
    }
  }

  static final public void inst_seleccion(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        String etiq, etiq2;
    try {
      jj_consume_token(tIF);
      expresion(at1);
      jj_consume_token(tTHEN);
                        at.code.addBlock(at1.code);
                        etiq = CGUtils.newLabel();
                        at.code.addInst(OpCode.JMF, etiq);
      lista_instrucciones(at);
                        sf.inst_seleccion_1(at1);
                        etiq2 = CGUtils.newLabel();
                        at.code.addInst(OpCode.JMP, etiq2);
                        at.code.addLabel(etiq);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tELSE:
        jj_consume_token(tELSE);
        lista_instrucciones(at);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
                 at.code.addLabel(etiq2);
      jj_consume_token(tEND);
    } catch (ParseException e) {
                Set<Integer> conjSinc = new HashSet<Integer>();
                conjSinc.add(tEND);
                recuperacionPanico(e.currentToken.next, conjSinc);
    }
  }

  static final public void inst_iteracion(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        String etiq = CGUtils.newLabel(), etiq2 = CGUtils.newLabel();
    try {
      jj_consume_token(tWHILE);
      expresion(at1);
                        sf.inst_iteracion_1(at1);

                        at.code.addLabel(etiq);
                        at.code.addBlock(at1.code);
                        at.code.addInst(OpCode.JMF, etiq2);
      jj_consume_token(tDO);
      lista_instrucciones(at);
      jj_consume_token(tEND);
                        at.code.addInst(OpCode.JMP, etiq);
                        at.code.addLabel(etiq2);
    } catch (ParseException e) {
                Set<Integer> conjSinc = new HashSet<Integer>();
                conjSinc.add(tEND);
                recuperacionPanico(e.currentToken.next, conjSinc);
    }
  }

//<tRETURN> expresion()
  static final public void inst_return(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        Token t;
    t = jj_consume_token(tRETURN);
    expresion(at1);
                sf.inst_return_1(at, at1, t);
                at.code.addBlock(at1.code);
                at.code.addInst(OpCode.CSF);
  }

/*	
	asignable()
	<tASSIGN>
	expresion()
*/
  static final public void inst_asignacion(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        Attributes at2 = new Attributes();
    asignable(at1);
    jj_consume_token(tASSIGN);
    expresion(at2);
                sf.inst_asignacion_1(at1, at2);
                at.code.addComment("asignando");
                at.code.addBlock(at1.code);
                at.code.addBlock(at2.code);
                at.code.addInst(OpCode.ASG);
  }

  static final public void lista_una_o_mas_asignable(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        at.expSize = 1;
    asignable(at1);
                at.listaCode.add(at1.code);
                at.listaTipo.add(at1.type);
                at1 = new Attributes();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tC:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_6;
      }
      jj_consume_token(tC);
      asignable(at1);
                at.listaCode.add(at1.code);
                at.listaTipo.add(at1.type);
                at.expSize++;
                at1 = new Attributes();
    }
  }

/*	LOOKAHEAD(2)
	<tID> <tISQBR> expresion_simple() <tESQBR>
	| <tID>*/
  static final public void asignable(Attributes at) throws ParseException {
        Token t;
        Attributes at1 = new Attributes();
        String etiq, etiq2;
    if (jj_2_3(2)) {
      t = jj_consume_token(tID);
         sf.asignable_1(t, at);
      jj_consume_token(tISQBR);
      expresion_simple(at1);
      jj_consume_token(tESQBR);
                sf.asignable_2(t, at1);
                at.code.addBlock(at1.code);
                at.code.addComment("Variable vector asignable " + t.image);
                at.code.addInst(OpCode.SRF, st.level - at.simbolo.nivel, (int)at.simbolo.dir);
                if(at.simbolo.parClass == Symbol.ParameterClass.REF){
                        at.code.addInst(OpCode.DRF);
                }
                at.code.addInst(OpCode.PLUS);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tID:
        t = jj_consume_token(tID);
                sf.asignable_3(t, at);
                at.code.addComment("Variable " + t.image);
                at.code.addInst(OpCode.SRF, st.level - at.simbolo.nivel, (int)at.simbolo.dir);
                if(at.simbolo.parClass == Symbol.ParameterClass.REF){
                        at.code.addInst(OpCode.DRF);
                }
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void inst_escribir(Attributes at) throws ParseException {
        Token t;
        Attributes at1 = new Attributes();
        at1.indice = 0;
    t = jj_consume_token(tPUT);
                sf.inst_escribir_1(t, at1);
    jj_consume_token(tSBR);
    lista_una_o_mas_exps(at1);
    jj_consume_token(tEBR);
                for(int i = at1.listaCode.size() - 1; i >= 0; i--){
                        at.code.addBlock(at1.listaCode.get(i));
                }

                for(int i = 0; i < at1.listaCode.size(); i++){
                        for(int j = 0; j < at1.listaSize.get(i); j++){
                                if(at1.listaTipo.get(i) == Symbol.Types.CHAR || at1.listaTipo.get(i) == Symbol.Types.STRING){
                                        at.code.addInst (OpCode.WRT, 0);
                                } else {
                                        at.code.addInst (OpCode.WRT, 1);
                                }
                        }
                }
  }

  static final public void inst_escribir_linea(Attributes at) throws ParseException {
        Token t;
        Attributes at1 = new Attributes();
        at1.indice = 0;
    t = jj_consume_token(tPUTL);
                sf.inst_escribir_linea_1(t, at1);


                at.code.addComment("put_line");
                at.code.addInst (OpCode.STC, 10);
                at.code.addInst (OpCode.STC, 13);
    jj_consume_token(tSBR);
    lista_cero_o_mas_exps(at1);
    jj_consume_token(tEBR);
                for(int i = at1.listaCode.size() - 1; i >= 0; i--){
                        at.code.addBlock(at1.listaCode.get(i));

                }

                for(int i = 0; i < at1.listaCode.size(); i++){
                        for(int j = 0; j < at1.listaSize.get(i); j++){
                                if(at1.listaTipo.get(i) == Symbol.Types.CHAR || at1.listaTipo.get(i) == Symbol.Types.STRING){
                                        at.code.addInst (OpCode.WRT, 0);
                                } else {
                                        at.code.addInst (OpCode.WRT, 1);
                                }
                        }
                }

                at.code.addInst (OpCode.WRT, 0);
                at.code.addInst (OpCode.WRT, 0);
  }

  static final public void inst_saltar_linea(Attributes at) throws ParseException {
        String etiq;
    jj_consume_token(tSKIP);
    jj_consume_token(tSBR);
    jj_consume_token(tEBR);
                etiq = CGUtils.newLabel();
                at.code.addLabel(etiq);
                at.code.addInst(OpCode.SRF, 0, CGUtils.memorySpaces[st.level] + 1);
                at.code.addInst(OpCode.RD, 0);
                at.code.addInst(OpCode.SRF, 0, CGUtils.memorySpaces[st.level] + 1);
                at.code.addInst(OpCode.DRF);
                at.code.addInst(OpCode.STC, 10);
                at.code.addInst(OpCode.EQ);
                at.code.addInst(OpCode.JMF, etiq);
  }

  static final public void inst_leer(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        Token t;
    t = jj_consume_token(tGET);
    jj_consume_token(tSBR);
    lista_una_o_mas_asignable(at1);
    jj_consume_token(tEBR);
                sf.inst_leer_1(t, at1);


                for(int i = at1.listaCode.size() - 1; i >= 0; i--){
                        at.code.addBlock(at1.listaCode.get(i));
                }


                for(int i = 0; i < at1.expSize; i++){
                        if(at1.listaTipo.get(i) == Symbol.Types.CHAR){
                                at.code.addInst (OpCode.RD, 0);
                        } else {
                                at.code.addInst (OpCode.RD, 1);
                        }
                }
  }

  static final public void lista_cero_o_mas_exps(Attributes at) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tVINT:
    case tVCHAR:
    case tTRUE:
    case tFALSE:
    case tVSTRING:
    case tSBR:
    case tNEG:
    case tPOS:
    case tNOT:
    case tI2C:
    case tC2I:
    case tID:
      lista_una_o_mas_exps(at);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
  }

//expresion(at1) ( <tC> expresion(at2) )*
  static final public void lista_una_o_mas_exps(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        at1.esLlamada = at.esLlamada;
    expresion(at1);
                sf.lista_una_o_mas_exps_1(at, at1);

                if(at.esLlamada && at1.parClass == Symbol.ParameterClass.REF){

                        if(at1.simbolo.type == Symbol.Types.ARRAY && !at1.interior.isEmpty()){

                                at.code.addBlock(at1.interior);
                        }
                        at.code.addInst(OpCode.SRF, st.level - at1.simbolo.nivel, (int)at1.simbolo.dir);
                        if(at1.simbolo.parClass == Symbol.ParameterClass.REF){
                                at.code.addInst(OpCode.DRF);
                        }

                        if(at1.simbolo.type == Symbol.Types.ARRAY && !at1.interior.isEmpty()){
                                at.code.addInst(OpCode.PLUS);
                                at1.interior.clearBlock();
                        }
                }
                else if(at.esLlamada && at1.type == Symbol.Types.ARRAY){
                        at1.arraySize = ((SymbolArray)at1.simbolo).maxInd;
                        for(int i = 0; i <= at1.arraySize; i++){
                                if(at1.simbolo.parClass == Symbol.ParameterClass.REF){
                                        at.code.addInst(OpCode.SRF, st.level - at1.simbolo.nivel, (int)at1.simbolo.dir);
                                        at.code.addInst(OpCode.DRF);
                                        at.code.addInst(OpCode.STC, i);
                                        at.code.addInst(OpCode.PLUS);
                                        at.code.addInst(OpCode.DRF);
                                }
                                else{   //Parametro vector val, argumento vector val
                                        at.code.addInst(OpCode.SRF, st.level - at1.simbolo.nivel, (int)at1.simbolo.dir + i);
                                        at.code.addInst(OpCode.DRF);
                                }
                        }
                }
                else if(at.esLlamada){
                        at.code.addBlock(at1.code);
                }


                at.listaCode.add(at1.code);
                at.listaTipo.add(at1.type);
                at.listaSize.add(at1.expSize);
                at1 = new Attributes();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tC:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_7;
      }
      jj_consume_token(tC);
      expresion(at1);
                sf.lista_una_o_mas_exps_1(at, at1);

                if(at.esLlamada && at1.parClass == Symbol.ParameterClass.REF){ //Miramos la clase del parametro
                        if(at1.simbolo.type == Symbol.Types.ARRAY && !at1.interior.isEmpty()){
                                at.code.addBlock(at1.interior);
                        }
                        at.code.addInst(OpCode.SRF, st.level - at1.simbolo.nivel, (int)at1.simbolo.dir);
                        if(at1.simbolo.parClass == Symbol.ParameterClass.REF){ //Miramos la clase del argumento
                                at.code.addInst(OpCode.DRF);
                        }

                        if(at1.simbolo.type == Symbol.Types.ARRAY && !at1.interior.isEmpty()){
                                at.code.addInst(OpCode.PLUS);
                                at1.interior.clearBlock();
                        }
                }
                else if(at.esLlamada && at1.type == Symbol.Types.ARRAY){
                        at1.arraySize = ((SymbolArray)at1.simbolo).maxInd;
                        for(int i = 0; i <= at1.arraySize; i++){
                                if(at1.simbolo.parClass == Symbol.ParameterClass.REF){  //Parametro vector val, argumento vector ref
                                        at.code.addInst(OpCode.SRF, st.level - at1.simbolo.nivel, (int)at1.simbolo.dir);
                                        at.code.addInst(OpCode.DRF);
                                        at.code.addInst(OpCode.STC, i);
                                        at.code.addInst(OpCode.PLUS);
                                        at.code.addInst(OpCode.DRF);
                                }
                                else{   //Parametro vector val, argumento vector val
                                        at.code.addInst(OpCode.SRF, st.level - at1.simbolo.nivel, (int)at1.simbolo.dir + i);
                                        at.code.addInst(OpCode.DRF);
                                }
                        }
                }
                else if(at.esLlamada){
                        at.code.addBlock(at1.code);
                }

                at.listaCode.add(at1.code);

                at.listaTipo.add(at1.type);
                at.listaSize.add(at1.expSize);
                at1 = new Attributes();
    }
  }

  static final public void expresion(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        Attributes at2 = new Attributes();
    expresion_simple(at);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tLESS:
    case tMORE:
    case tLESSEQ:
    case tMOREEQ:
    case tNOTEQ:
    case tEQ:
      operador_relacional(at2);
      expresion_simple(at1);
                        sf.expresion_1(at, at1);

                        at.code.addBlock(at1.code);
                        at.code.addBlock(at2.code);
                        at1.code.clearBlock();
                        at2.code.clearBlock();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
  }

  static final public void operador_relacional(Attributes at) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tEQ:
      jj_consume_token(tEQ);
               at.code.addInst (OpCode.EQ);
      break;
    case tLESS:
      jj_consume_token(tLESS);
                   at.code.addInst (OpCode.LT);
      break;
    case tMORE:
      jj_consume_token(tMORE);
                   at.code.addInst (OpCode.GT);
      break;
    case tLESSEQ:
      jj_consume_token(tLESSEQ);
                     at.code.addInst (OpCode.LTE);
      break;
    case tMOREEQ:
      jj_consume_token(tMOREEQ);
                     at.code.addInst (OpCode.GTE);
      break;
    case tNOTEQ:
      jj_consume_token(tNOTEQ);
                    at.code.addInst (OpCode.NEQ);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
(<tPOS>| <tNEG>)? termino() ( operador_aditivo(at2) termino(at3))*
*/
  static final public void expresion_simple(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        Attributes at2 = new Attributes();
        Attributes at3 = new Attributes();
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tNEG:
    case tPOS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPOS:
        t = jj_consume_token(tPOS);
        break;
      case tNEG:
        t = jj_consume_token(tNEG);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                sf.expresion_simple_1(at1);
                if(t.image == "-"){
                        at1.code.addInst (OpCode.NGI);
                }
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    termino(at);
                sf.expresion_simple_2(at, at1);
                at.code.addBlock(at1.code);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tNEG:
      case tPOS:
      case tOR:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_8;
      }
      operador_aditivo(at2);
      termino(at3);
                sf.expresion_simple_3(at, at2, at3);

                at.code.addBlock(at3.code);
                at.code.addBlock(at2.code);
                at2.code.clearBlock();
                at3.code.clearBlock();
    }
  }

// <tPOS> 
// | <tNEG>
// | <tOR> 
  static final public void operador_aditivo(Attributes at) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tPOS:
      jj_consume_token(tPOS);
                at.type = Symbol.Types.INT; at.code.addInst (OpCode.PLUS);
      break;
    case tNEG:
      jj_consume_token(tNEG);
                  at.type = Symbol.Types.INT; at.code.addInst (OpCode.SBT);
      break;
    case tOR:
      jj_consume_token(tOR);
                 at.type = Symbol.Types.BOOL; at.code.addInst (OpCode.OR);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//factor() ( operador_multiplicativo() factor() )*
  static final public void termino(Attributes at) throws ParseException {
        Attributes at1 = new Attributes();
        Attributes at2 = new Attributes();
        Attributes at3 = new Attributes();
    factor(at);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tMUL:
      case tDIV:
      case tMOD:
      case tAND:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_9;
      }
      operador_multiplicativo(at2);
      factor(at3);
                sf.termino_2(at, at2, at3);

                at.code.addBlock(at3.code);
                at.code.addBlock(at2.code);
                at2.code.clearBlock();
                at3.code.clearBlock();
    }
  }

  static final public void operador_multiplicativo(Attributes at) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMUL:
      jj_consume_token(tMUL);
                at.type = Symbol.Types.INT; at.code.addInst (OpCode.TMS);
      break;
    case tMOD:
      jj_consume_token(tMOD);
                  at.type = Symbol.Types.INT; at.code.addInst (OpCode.MOD);
      break;
    case tDIV:
      jj_consume_token(tDIV);
                  at.type = Symbol.Types.INT; at.code.addInst (OpCode.DIV);
      break;
    case tAND:
      jj_consume_token(tAND);
                  at.type = Symbol.Types.BOOL; at.code.addInst (OpCode.AND);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void factor(Attributes at) throws ParseException {
        Token t;
        Attributes at1 = new Attributes();
        at1.indice = 0;
        String etiq, etiq2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tNOT:
      jj_consume_token(tNOT);
      factor(at1);
                sf.factor_1(at, at1);
                at.code.addBlock(at1.code);
                at.code.addInst(OpCode.NGB);
                at.expSize=at1.expSize;
      break;
    case tSBR:
      jj_consume_token(tSBR);
      expresion(at1);
      jj_consume_token(tEBR);
                sf.factor_2(at, at1);
                at.code.addBlock(at1.code);
                at.expSize=at1.expSize;
      break;
    case tI2C:
      jj_consume_token(tI2C);
      jj_consume_token(tSBR);
      expresion(at1);
      jj_consume_token(tEBR);
                sf.factor_3(at, at1);
                at.code.addBlock(at1.code);
                at.expSize=1;
      break;
    case tC2I:
      jj_consume_token(tC2I);
      jj_consume_token(tSBR);
      expresion(at1);
      jj_consume_token(tEBR);
                sf.factor_4(at, at1);
                at.code.addBlock(at1.code);
                at.expSize=1;
      break;
    default:
      jj_la1[27] = jj_gen;
      if (jj_2_4(2)) {
        t = jj_consume_token(tID);
                sf.factor_13(t, at1);
                at1.esLlamada = true;
        jj_consume_token(tSBR);
        lista_cero_o_mas_exps(at1);
        jj_consume_token(tEBR);
                sf.factor_5(at1, at);

                at.code.addBlock(at1.code);
                at.code.addOSFInst(CGUtils.memorySpaces[st.level] + 1, st.level - at1.simbolo.nivel, at1.simbolo.label);
                at.expSize=1;
      } else if (jj_2_5(2)) {
        t = jj_consume_token(tID);
        jj_consume_token(tISQBR);
        expresion(at1);
        jj_consume_token(tESQBR);
                sf.factor_6(t, at, at1);

                at.interior.addBlock(at1.code);
                at.code.addBlock(at1.code);
                at.code.addComment("Variable vector factor " + t.image);
                at.code.addInst(OpCode.SRF, st.level - at.simbolo.nivel, (int)at.simbolo.dir);
                if(at.simbolo.parClass == Symbol.ParameterClass.REF){
                        at.code.addInst(OpCode.DRF);
                }
                at.code.addInst(OpCode.PLUS);
                at.code.addInst(OpCode.DRF);

                at.expSize=1;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tID:
          t = jj_consume_token(tID);
                sf.factor_7(t, at);

                at.code.addComment("coger variable " + t.image);

                at.code.addInst(OpCode.SRF, st.level - at.simbolo.nivel, (int)at.simbolo.dir);
                at.code.addInst(OpCode.DRF);
                if(at.simbolo.parClass == Symbol.ParameterClass.REF){
                        at.code.addInst(OpCode.DRF);
                }

                at.expSize=1;
          break;
        case tVINT:
          t = jj_consume_token(tVINT);
                sf.factor_8(t, at);
                at.code.addComment("coger constante entera " + t.image);
                at.expSize=1;
                at.code.addInst(OpCode.STC, at.valInt);
          break;
        case tVCHAR:
          t = jj_consume_token(tVCHAR);
                sf.factor_9(t, at);
                at.code.addComment("Coger caracter " + at.valChar);
                at.code.addInst (OpCode.STC, (int) at.valChar);
                at.expSize=1;
          break;
        case tVSTRING:
          t = jj_consume_token(tVSTRING);
                sf.factor_10(t, at);
                at.code.addComment("coger constante string "  + t.image);
                for (int i = at.valString.length() - 2; i >= 1; i--) {
                        at.code.addInst (OpCode.STC, (int) at.valString.charAt(i));
                }
                at.expSize = at.valString.length() - 2;
          break;
        case tTRUE:
          jj_consume_token(tTRUE);
                sf.factor_11(at);
                at.code.addInst (OpCode.STC, 1);
                at.expSize=1;
          break;
        case tFALSE:
          jj_consume_token(tFALSE);
                sf.factor_12(at);
                at.code.addInst (OpCode.STC, 0);
                at.expSize=1;
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  static Set<Integer> infoParseException(ParseException e) throws ParseException {
        Set<Integer> esperados = new HashSet<Integer>();
        System.err.println("ERROR_SINT: ('" + e.currentToken.next.image + "',"
                + e.currentToken.next.beginLine
                + "," + e.currentToken.next.beginColumn + ")");
        System.err.println("Se esperaba uno de los siguientes tokens:");
        for(int i = 0; i < e.expectedTokenSequences.length; i++){
                esperados.add(e.expectedTokenSequences[i][0]);
                System.err.println("\t" + adac_4Constants.tokenImage[e.expectedTokenSequences[i][0]]);
        }
        return esperados;
  }

  static void recuperacionPanico(Token tInesperado, Set<Integer> conjSinc) throws ParseException {
        System.err.println("----> Recupero en modo panico: " +
        "\n ----> saltando todo hasta token de conjunto de sincronizacion");
        Token t = getNextToken();
        while (!conjSinc.contains(t.kind) && t.kind != EOF) {
                System.err.println("Descartando token ("
                + adac_4Constants.tokenImage[t.kind]
                + "," + t.image + ")");

                t = getNextToken();
        }
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_3R_10() {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tSBR)) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tSBR)) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tISQBR)) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tISQBR)) return true;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tISQBR)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_10()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public adac_4TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  /** Whether we are looking ahead. */
  static private boolean jj_lookingAhead = false;
  static private boolean jj_semLA;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[29];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1c00,0x1c00,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x8013e000,0x40000,0x5f000000,0x5f000000,0x80000000,0x80000000,0x80000000,0x80000000,0x0,0x0,0x100000,0x3e000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x2000000,0x180,0x180,0xc00,0xc00,0xc00,0x0,0xc00,0x51e200,0x2000000,0x251e200,0x200000,0x0,0x2000000,0x2060021,0x0,0x0,0x0,0x1,0x1,0x41,0x41,0x1e,0x1e,0x60020,0x2000000,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[5];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public adac_4(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public adac_4(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new adac_4TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public adac_4(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new adac_4TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public adac_4(adac_4TokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(adac_4TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.add(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[59];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 29; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 59; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
